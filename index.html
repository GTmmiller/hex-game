<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Hexagon Fun</title>
  <meta name="description" content="My continued study into hexagons">
  <meta name="author" content="Steven Miller">

  <link rel="stylesheet" href="css/styles.css?v=1.0">

</head>

<body>
  <script src="js/fabric.js"></script>
  <div id='canvas-box'>
    <canvas id="test" width="900" height="900">This browser does not support canvas</canvas>
  </div>
  
  <script>
    let canvas = new fabric.Canvas('test')
    console.log(canvas.getWidth())
    console.log(canvas.getHeight())

    // gamestate should be a pojo => class object
    let gamestate = {
      turn: 0,
      player: 1,
      colors: { 
        1: 'red',
        2: 'blue'
      },
      // p by q
      usedTiles: {
      }
    }

    const Hexagon = fabric.util.createClass(fabric.Polygon, {
      initialize: function (options) {
        // Use the size to create the initial coordinates
        // for a regular hexagon in the pointed top configuration
        this.size = options.size || 0
        this.width = Math.sqrt(3) * this.size
        this.height = 2 * this.size
        let points = [
          // top point then clockwise
          { x: this.width * 0.5, y: 0 },
          { x: this.width, y: this.height * 0.25 },
          { x: this.width, y: this.height * 0.75 },
          { x: this.width * 0.5, y: this.height },
          { x: 0, y: this.height * 0.75 },
          { x: 0, y: this.height * 0.25 }
        ]
        this.callSuper('initialize', points, options) 
      }
    })

    const HexTile = fabric.util.createClass(Hexagon, {
      initialize: function(options, gamestate) {
        this.gamestate = gamestate
        this.callSuper('initialize', options)
      }
    })

    const hexTileEvents = function(hexTile) {
      hexTile.on('mousedown', function(e) {
        // Make sure that the tile isn't colored yet
        let tile = e.target
        if (!Object.values(this.gamestate.colors).includes(tile.get('fill'))) {
          let color = this.gamestate.colors[this.gamestate.player]
        
          if (color === undefined) {
            throw Error(`Incorrect player taking turn: '${this.gamestate.player}'`)
          }
          tile.set({fill: color})
          if (this.gamestate.player === 1) {
            this.gamestate.player = 2
          } else {
            this.gamestate.player = 1
          }
        }
      })
    }
    
    // Render the board in a rombus pattern
    const refHexagon = new Hexagon({size: 30})
    const boardWidth = 11
    const boardHeight = 11
    const startTop = 50
    const startLeft = 50
    let hexGrid = []
    for (let i = 0; i < boardHeight; i++) {
      let leftPush = startLeft + (refHexagon.width / 2) * i
      hexGrid.push([])
      for(let j = 0; j < boardWidth; j++) {
        let newHex = new HexTile({
          top: startTop + i * refHexagon.height * 0.75, 
          left: leftPush + j * refHexagon.width, size: 30, 
          stroke: 'black', 
          fill: 'white' 
        }, gamestate)
        hexTileEvents(newHex)
        hexGrid[i].push(newHex)
        canvas.add(newHex)
      }
    }

    // working on board lines
    let rect = new fabric.Rect({top: 75, left: 50, width: 30, height: 500, angle: -90, fill: 'red'})
    let line = new fabric.Line([50 - refHexagon.width, 50, 50, 500], {stroke: 'black'})
    canvas.add(rect)
    rect.sendToBack()


  </script>
</body>
</html>